# Dev to Prod Fast

This repository demonstrates a fully automated release workflow that moves code from development to production safely and transparently, using [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/), [Semantic Versioning](https://semver.org/), and signed releases. The goal is to show how teams can automate versioning, tagging, and release publication, all without manual intervention or risk of inconsistency.

- [Dev to Prod Fast](#dev-to-prod-fast)
  - [Overview](#overview)
  - [Structure](#structure)
    - [Repository files](#repository-files)
    - [Plugins flow](#plugins-flow)
    - [Configuration](#configuration)
      - [Variables](#variables)
      - [Secrets](#secrets)
  - [Design decisions and rationale](#design-decisions-and-rationale)
    - [üß© Why use a GitHub App Token instead of a Personal Access Token (PAT)](#-why-use-a-github-app-token-instead-of-a-personal-access-token-pat)
    - [üîê Why the signing key belongs to a bot, not the App](#-why-the-signing-key-belongs-to-a-bot-not-the-app)
    - [üóæ Why we don't force tag signing by default](#-why-we-dont-force-tag-signing-by-default)
    - [üìò Why we don't commit a `CHANGELOG.md`](#-why-we-dont-commit-a-changelogmd)
  - [How to use this repository](#how-to-use-this-repository)
    - [Adding a new feature](#adding-a-new-feature)
    - [How Conventional Commits affect versioning](#how-conventional-commits-affect-versioning)
  - [Future improvements](#future-improvements)

## Overview

On every push to `main` wether it is direct or via a Pull request the workflow (`.github/workflows/cicd-2-publish.yaml`) runs the process to:

1. Analyze commits based on conventional commits practice to decide the next version
2. Write the new version into `VERSION`
3. Commit the version file with a release message
4. Create the tag
5. Publish a GitHub Release with canonical release notes

Whenever code is pushed or merged into the `main` branch, the workflow
[`.github/workflows/cicd-2-publish.yaml`](./.github/workflows/cicd-2-publish.yaml) automatically:

1. Analyses commit messages to determine what type of release is needed (major, minor, patch)
2. Calculates the next semantic version and writes it into the VERSION file
3. Commits that file with a standardised, signed release message
4. Creates a corresponding Git tag (e.g. v1.2.3)
5. Publishes a GitHub Release entry with autogenerated notes derived from the commits.

In short, every release is predictable, traceable, and entirely automated.

## Structure

### Repository files

| File                                    | Purpose                                                                                                       |
| --------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| `.github/workflows/cicd-2-publish.yaml` | The GitHub Actions workflow that orchestrates authentication, key import, and the semantic-release execution. |
| `.releaserc`                            | Defines how semantic-release runs, which plugins are used, and how each stage behaves.                        |
| `VERSION`                               | A plain-text file containing the current version, updated automatically during each release.                  |

### Plugins flow

Order in `.releaserc`:

Semantic-release works as a modular pipeline. In this configuration, the stages run in this order:

1. `@semantic-release/commit-analyzer` reads commits to decide whether to bump the major, minor, or patch version
2. `@semantic-release/release-notes-generator` converts commit history into human-readable release notes
3. `@semantic-release/exec` writes the new version string (${nextRelease.version}) into the VERSION file
4. `@semantic-release/git` commits that change with a consistent message such as chore(release): 1.2.0 [skip ci]
5. `@semantic-release/github` publishes a GitHub Release entry with the generated notes

The process ensures that version bumps, tags, and release notes are always consistent with your commit history.

### Configuration

#### Variables

These are configured as repository variables:

- `GH_APP_ID` - the GitHub App's numeric ID
- `GIT_SIGN_BOT_NAME` - display name for the bot account used for signing commits
- `GIT_SIGN_BOT_EMAIL` - email linked to the GPG key uploaded to GitHub

#### Secrets

These are stored as repository secrets:

- `GH_APP_PRIVATE_KEY` - the App's private PEM key for authentication
- `GIT_SIGN_BOT_GPG_PRIVATE_KEY` - ASCII-armoured GPG private key for the signing bot
- `GIT_SIGN_BOT_GPG_PASSPHRASE` - optional passphrase, can be blank if the key is unprotected

## Design decisions and rationale

This section captures the thinking behind some key design choices.

### üß© Why use a GitHub App Token instead of a Personal Access Token (PAT)

Using a GitHub App offers significant security and governance advantages:

- Least privilege, the App's installation can be scoped to specific repos with tightly controlled permissions
- Ephemeral credentials, tokens are short-lived and automatically rotated, minimising the impact of leaks
- Easy revocation, uninstalling the App immediately cuts off access, no manual key rotation needed
- Auditability, actions performed by the App are attributed to its installation in GitHub logs
- Operational separation, avoids depending on a human user's PAT, which could carry excessive scopes or expire unexpectedly

In practice, this means safer automation with better traceability and compliance.

### üîê Why the signing key belongs to a bot, not the App

GitHub verifies GPG and SSH signatures against user or bot accounts, not apps. Because of that, the release workflow uses a dedicated bot identity that owns the signing key. The benefits are as follows:

- Commits and tags show the green "Verified" badge, proving authenticity
- Release authorship is clearly separate from individual developers
- Keys can be rotated independently of personal credentials
- Auditing is straightforward, every release is traceable to a single, consistent bot identity

The public key must be uploaded to the GitHub profile of the account listed in `GIT_SIGN_BOT_EMAIL` to ensure signatures validate correctly.

### üóæ Why we don't force tag signing by default

Tag signing can be valuable, but it adds complexity in non-interactive CI environments. Here's why it's disabled by default:

- Simplicity, signed annotated tags require a message, without it, Git tries to open an editor and fails in CI
- Reliability, lightweight tags work flawlessly with semantic-release, annotated tags can hang or error if GPG or message handling is misconfigured
- Sufficient provenance, signed commits combined with GitHub Releases already provide a trustworthy audit trail

If you later want to add signed annotated tags, you can do so safely once your workflow is stable, e.g.:

```bash
git tag -a -m "vX.Y.Z" vX.Y.Z && git push --force origin vX.Y.Z
```

### üìò Why we don't commit a `CHANGELOG.md`

Instead of maintaining a growing Markdown changelog, this design treats GitHub Releases as the single source of truth. Each release contains its own autogenerated notes, which are easy to view, compare, or query via API. Advantages are:

- Single source of truth, release notes live where users expect them, in the Releases tab
- Cleaner history, release commits only touch the `VERSION` file, avoiding noisy changelog diffs
- Fewer merge conflicts, no simultaneous changelog edits across branches
- Better performance, no rewriting of a large markdown file every release
- API-friendly, release data is structured and accessible via GitHub's API for dashboards or audits

If an on-disk changelog is ever needed (e.g. for packaged distributions), re-enable `@semantic-release/changelog` or build an export pipeline that generates one on demand.

## How to use this repository

### Adding a new feature

1. Create a branch and commit changes using Conventional Commits, for example:

   ```plaintext
   feat(api): add user authentication
   ```

2. Open a Pull Request and merge it into `main`
3. The workflow will:

   - Detect that the change type is `feat` ‚Üí trigger a **minor** version bump
   - Update the `VERSION` file
   - Commit and tag the new release
   - Publish release notes automatically

You'll see the new tag and release appear on GitHub, both signed and verified (commit).

### How Conventional Commits affect versioning

| Type                          | Example                           | Release bump |
| ----------------------------- | --------------------------------- | ------------ |
| `docs`                        | `docs(readme): update section`    | no bump      |
| `chore`                       | `chore(release): housekeeping`    | no bump      |
| `fix`                         | `fix(ci): correct signing config` | patch        |
| `perf`                        | `perf(core): improve runtime`     | patch        |
| `refactor`                    | `refactor(ci): simplify logic`    | patch        |
| `feat`                        | `feat(ci): add exec plugin`       | minor        |
| `feat!:` or `BREAKING CHANGE` | `feat!: remove deprecated option` | major        |

## Future improvements

- **Add commit linting**: enforce Conventional Commit style at PR level
- **Enhance traceability**: generate a metadata file including version, commit SHA, and timestamp
- **GitHub PR configuration**: provide compatible GitHub settings for PR merging
- **Extend to multi-repo setups**: explore one signing key and App per organisation for consistent release provenance
- **Publish build artefacts**: e.g., npm packages or Docker images using extra semantic-release plugins
