# Dev to Prod Fast Release

This repository demonstrates a fully automated release workflow that moves code from development to production safely and transparently, using [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/), [Semantic Versioning](https://semver.org/), and signed releases. The goal is to show how teams can automate versioning, tagging, and release publication, all without manual intervention or risk of inconsistency.

- [Dev to Prod Fast Release](#dev-to-prod-fast-release)
  - [Overview](#overview)
  - [Structure](#structure)
    - [Repository files](#repository-files)
    - [Plugins flow](#plugins-flow)
    - [Configuration](#configuration)
      - [Variables](#variables)
      - [Secrets](#secrets)
  - [Prerequisites](#prerequisites)
    - [GitHub App setup](#github-app-setup)
    - [User bot setup](#user-bot-setup)
  - [Design decisions and rationale](#design-decisions-and-rationale)
    - [üß© Why use a GitHub App Token instead of a Personal Access Token (PAT)](#-why-use-a-github-app-token-instead-of-a-personal-access-token-pat)
    - [üîê Why the signing key belongs to a bot, not the App](#-why-the-signing-key-belongs-to-a-bot-not-the-app)
    - [üóæ Why we don't force tag signing by default](#-why-we-dont-force-tag-signing-by-default)
    - [üìò Why we don't commit a `CHANGELOG.md`](#-why-we-dont-commit-a-changelogmd)
  - [How to use this repository](#how-to-use-this-repository)
    - [Adding a new feature](#adding-a-new-feature)
    - [How Conventional Commits affect versioning](#how-conventional-commits-affect-versioning)

## Overview

On every push to `main` wether it is direct or via a Pull request the workflow (`.github/workflows/cicd-2-publish.yaml`) runs the process to:

1. Analyze commits based on conventional commits practice to decide the next version
2. Write the new version into `VERSION`
3. Commit the version file with a release message
4. Create the tag
5. Publish a GitHub Release with canonical release notes

Whenever code is pushed or merged into the `main` branch, the workflow
[`.github/workflows/cicd-2-publish.yaml`](./.github/workflows/cicd-2-publish.yaml) automatically:

1. Analyses commit messages to determine what type of release is needed (major, minor, patch)
2. Calculates the next semantic version and writes it into the VERSION file
3. Commits that file with a standardised, signed release message
4. Creates a corresponding Git tag (e.g. v1.2.3)
5. Publishes a GitHub Release entry with autogenerated notes derived from the commits.

In short, every release is predictable, traceable, and entirely automated.

## Structure

### Repository files

| File                                    | Purpose                                                                                                       |
| --------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| `.github/workflows/cicd-2-publish.yaml` | The GitHub Actions workflow that orchestrates authentication, key import, and the semantic-release execution. |
| `.releaserc`                            | Defines how semantic-release runs, which plugins are used, and how each stage behaves.                        |
| `VERSION`                               | A plain-text file containing the current version, updated automatically during each release.                  |

### Plugins flow

Order in `.releaserc`:

Semantic-release works as a modular pipeline. In this configuration, the stages run in this order:

1. `@semantic-release/commit-analyzer` reads commits to decide whether to bump the major, minor, or patch version
2. `@semantic-release/release-notes-generator` converts commit history into human-readable release notes
3. `@semantic-release/exec` writes the new version string (${nextRelease.version}) into the VERSION file
4. `@semantic-release/git` commits that change with a consistent message such as chore(release): 1.2.0 [skip ci]
5. `@semantic-release/github` publishes a GitHub Release entry with the generated notes

The process ensures that version bumps, tags, and release notes are always consistent with your commit history.

### Configuration

#### Variables

Repository variables define the static configuration needed by the workflow:

- `GH_APP_ID` - numeric ID of the GitHub App
- `GIT_SIGN_BOT_NAME` - the display name used for the bot's signed commits
- `GIT_SIGN_BOT_EMAIL` - the bot's email address (must match the uploaded GPG key)

#### Secrets

Repository secrets provide the credentials and cryptographic materials required to sign releases:

- `GH_APP_PRIVATE_KEY` - the GitHub App's private PEM key (used for authentication)
- `GIT_SIGN_BOT_GPG_PRIVATE_KEY` - the ASCII-armoured private GPG key of the signing bot
- `GIT_SIGN_BOT_GPG_PASSPHRASE` - the GPG key passphrase

## Prerequisites

### GitHub App setup

Follow these steps to create and configure a minimal‚Äëpermission GitHub App that will authenticate the release workflow. This should be done for you by the NHS GitHub Admins. You should have to do this ourself testing.

1. Create the App

   - Go to [GitHub App settings](https://github.com/settings/apps) user _Settings ‚Üí Developer Settings ‚Üí GitHub Apps ‚Üí New GitHub App_
   - Name it something like _"My Dev to Prod Fast Release App"_ (must be globally unique)
   - Set the homepage URL to your repository
   - Configure permissions
     - Repository permissions:
       - _Contents: Read & write_ (needed to create tags and commit `VERSION`)
       - _Issues: Read & write_ (enables adding release notes comments)
       - _Pull requests: Read & write_ (allows future PR commenting automation)
       - All other repository permissions: No access
     - _Organization permissions: None required_
     - _Account permissions: None required_
   - For the installation scope choose _Only on this account_ (or organisation-wide if required)

2. Generate the private key

   - After saving, click _Generate a private key_
   - Copy the full `.pem` file contents (including BEGIN/END lines)
   - Store it securely, you'll need it to populate `GH_APP_PRIVATE_KEY`

3. Install the App

   - Click _Install App_ on the App page
   - Choose your user account
   - Select _Only select repositories_ ‚Üí pick this repository (recommended) or _All repositories_ (broader scope-only if necessary)

4. Add repository variables & secrets

   - Go to your repository ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions
   - Add the variables and secrets listed above

5. Test

   - Make a trivial commit e.g. `docs: test app token wiring` to `main`
   - In workflow logs confirm the _"Generate GitHub App token"_ step succeeds

   After setup, this step in your workflow will issue short-lived authentication tokens automatically:

   ```yaml
   - name: Generate GitHub App token
   uses: actions/create-github-app-token@v2
   with:
       app-id: ${{ vars.GH_APP_ID }}
       private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
   ```

### User bot setup

TODO: [Create GPG key](https://github.com/nhs-england-tools/repository-template/blob/main/docs/user-guides/Sign_Git_commits.md)

## Design decisions and rationale

This section captures the thinking behind some key design choices.

### üß© Why use a GitHub App Token instead of a Personal Access Token (PAT)

Using a GitHub App offers significant security and governance advantages:

- Least privilege, the App's installation can be scoped to specific repos with tightly controlled permissions
- Ephemeral credentials, tokens are short-lived and automatically rotated, minimising the impact of leaks
- Easy revocation, uninstalling the App immediately cuts off access, no manual key rotation needed
- Auditability, actions performed by the App are attributed to its installation in GitHub logs
- Operational separation, avoids depending on a human user's PAT, which could carry excessive scopes or expire unexpectedly

In practice, this means safer automation with better traceability and compliance.

### üîê Why the signing key belongs to a bot, not the App

GitHub verifies GPG and SSH signatures against user or bot accounts, not apps. Because of that, the release workflow uses a dedicated bot identity that owns the signing key. The benefits are as follows:

- Commits and tags show the green "Verified" badge, proving authenticity
- Release authorship is clearly separate from individual developers
- Keys can be rotated independently of personal credentials
- Auditing is straightforward, every release is traceable to a single, consistent bot identity

The public key must be uploaded to the GitHub profile of the account listed in `GIT_SIGN_BOT_EMAIL` to ensure signatures validate correctly.

### üóæ Why we don't force tag signing by default

Tag signing can be valuable, but it adds complexity in non-interactive CI environments. Here's why it's disabled by default:

- Simplicity, signed annotated tags require a message, without it, Git tries to open an editor and fails in CI
- Reliability, lightweight tags work flawlessly with semantic-release, annotated tags can hang or error if GPG or message handling is misconfigured
- Sufficient provenance, signed commits combined with GitHub Releases already provide a trustworthy audit trail

If you later want to add signed annotated tags, you can do so safely once your workflow is stable, e.g.:

```bash
git tag -a -m "vX.Y.Z" vX.Y.Z && git push --force origin vX.Y.Z
```

### üìò Why we don't commit a `CHANGELOG.md`

Instead of maintaining a growing Markdown changelog, this design treats GitHub Releases as the single source of truth. Each release contains its own autogenerated notes, which are easy to view, compare, or query via API. Advantages are:

- Single source of truth, release notes live where users expect them, in the Releases tab
- Cleaner history, release commits only touch the `VERSION` file, avoiding noisy changelog diffs
- Fewer merge conflicts, no simultaneous changelog edits across branches
- Better performance, no rewriting of a large markdown file every release
- API-friendly, release data is structured and accessible via GitHub's API for dashboards or audits

If an on-disk changelog is ever needed (e.g. for packaged distributions), re-enable `@semantic-release/changelog` or build an export pipeline that generates one on demand.

## How to use this repository

### Adding a new feature

1. Create a branch and commit changes using Conventional Commits, for example:

   ```plaintext
   feat(api): add user authentication
   ```

2. Open a Pull Request and merge it into `main`, ensure that the commit created as an effect of merging this PR contains the above message as this drives the sematic versioning
3. The workflow will:

   - Detect that the change type is `feat` ‚Üí trigger a **minor** version bump
   - Update the `VERSION` file
   - Commit and tag the new release
   - Publish release notes automatically

You'll see the new tag and release appear on GitHub, both signed and verified (commit).

### How Conventional Commits affect versioning

| Type              | Example                                  | Release bump | Explanation                                                                                                 |
| ----------------- | ---------------------------------------- | ------------ | ----------------------------------------------------------------------------------------------------------- |
| `docs`            | `docs(readme): update section`           | no bump      | Documentation-only change, does not affect the application's behaviour or API                               |
| `style`           | `style(css): normalise headings`         | no bump      | Code style or formatting change (e.g. whitespace, lint fixes) - no functional impact                        |
| `chore`           | `chore(release): housekeeping`           | no bump      | Maintenance or tooling updates unrelated to user-facing code                                                |
| `test`            | `test(ci): add smoke tests`              | no bump      | Adds or modifies tests, does not change runtime or API behaviour                                            |
| `refactor`        | `refactor(ci): simplify logic`           | patch        | Code improvement or cleanup without changing behaviour, treated like a small fix                            |
| `fix`             | `fix(ci): correct signing config`        | patch        | Corrects an existing issue, triggers a patch version bump (`x.y.z ‚Üí x.y.(z+1)`)                             |
| `perf`            | `perf(core): improve runtime`            | patch        | Performance enhancement without altering external behaviour, treated as a patch                             |
| `feat`            | `feat(ci): add exec plugin`              | minor        | Introduces a new, backward-compatible feature, triggers a minor version bump (`x.y.z ‚Üí x.(y+1).0`)          |
| `<type>[scope]!:` | `feat(api)!: remove deprecated endpoint` | major        | Introduces a breaking change (non-backward-compatible), triggers a major version bump (`x.y.z ‚Üí (x+1).0.0`) |
